# DatTCP

DatTCP is a generic threaded server implementation using Ruby's `TCPServer`. It is heavily influenced by `GServer` and [Puma](http://puma.io) and built using many of their patterns.

## Usage

```ruby
class MyServer
  include DatTCP::Server

  def serve!(socket)
    # read from socket
    # write to socket
  end

end
```

Define your own server by mixing in `DatTCP::Server`.  Implementing a `serve` method that accepts a socket instance. DatTCP will call the `serve` method for each new connection it receives.

A separate thread is used for every connection. This means that the `serve` method should be threadsafe, as multiple threads may call it simultaneously.

### Starting

```ruby
server = MyServer.new({ :min_workers => 1 })
server.listen('localhost', 12000)
server.run
```

Create an instance of your server and optionally override any default settings. Call `listen` to build a `TCPServer` and bind to an address and port. Finally, call `run` to begin accepting and queueing connections to serve.

The `run` method returns the thread that is accepting connections.  Typically, you will want to `join` this thread so that it can perpetually accept connections:

```ruby
server.run.join
```

The server will then continue processing connections until it is signalled to stop or its process is killed.

### Handling Connections

```ruby
def serve!(socket)
  message = socket.read
  socket.write(message)
end
```

To handle a client connection, define a `serve` method that accepts a `TCPSocket` instance that can be read from and written to.

### Stopping

Once the server has been started, it can be stopped using the `stop` method. Obviously, this can only be done in the current process if you didn't join the server thread:

```ruby
server.stop
```

If you plan to join the server thread, it's useful to setup signal traps so you can signal the server to stop:

```ruby
Signal.trap('TERM'){ server.stop }
server.run.join
```

```sh
# assume our process id is 12345
$ kill -TERM 12345
```

## Customization

### Configuration

* `backlog_size`     - The number of connections that can be pending. These
                       are connections that haven't been 'accepted' by the
                       server.
* `min_workers`      - The minimum number of threads available to handle
                       connections.
* `max_workers`      - The maximum number of threads to spin up to handle
                       connections.
* `ready_timeout`    - The number of seconds the server will wait for a new
                       connection. This controls the "responsiveness" of the
                       server; how fast it will perform checks, like detecting
                       if it has been signaled to stop.
* `shutdown_timeout` - The number of seconds the server will wait for workers
                       to finish serving a connection. If they don't finish in
                       this time, the server will continue shutting down.
* `debug`            - Output debug messages or not.

### Hooks

A DatTCP server also has a number of hooks for adding custom behavior when different events occur:

* `configure_tcp_server` - Called after an instance of `TCPServer` is created,
                           but before it starts listening. The instance will
                           be passed to this method, so this can be used to
                           set socket options as needed.
* `on_listen`            - Called when `listen` is called.
* `on_run`               - Called when `run` is called.
* `on_pause`             - Called when `pause` is called.
* `on_stop`              - Called when `stop` is called.
* `on_halt`              - Called when `halt` is called.

## Benchmarking

DatTCP comes with some rake tasks for benchmarking it's performance. These generate report text files that should be used to see if any additions or changes have altered it's previous performance. These can be run by doing the following:

In a shell, start the server:

```bash
bundle exec rake bench:server
```

This will start the server which will begin listening for requests. The report can then be generated by running this rake task in another shell:

```bash
bundle exec rake bench:report
```

This will both output the results to STDOUT and to a report file. When the server is stopped, it will also write out some statistics on how long it spent processing.

### Notes

* The bench server is an echo server, it writes back whatever it was sent. Modifying the message sent, from what it currently is, will probably negatively impact performance and can no longer be compared with any historical reports.
* The calculations should be at a very minute scale (a single request should take around 1ms and probably less). This means it can vary from run to run. I recommend running it ~5 times and keeping the lowest results. In general, requests shouldn't take much longer than a 1ms on average.

## Installation

Add this line to your application's Gemfile:

    gem 'dat-tcp'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install dat-tcp

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Added some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

